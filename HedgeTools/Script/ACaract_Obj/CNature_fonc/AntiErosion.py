# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# AntiErosion.py
# Created on: 2013-07-17 15:18:32.00000
#   (generated by ArcGIS/ModelBuilder)
# Usage: AntiErosion <MNT> <ReseauHaie> <HAIAntiErosif>
# Description: Cherche les haie qui se situe sur une pente supérieur à 7 °
# et dont l'orientation est perpendiculaire à +- l'angle spéficiée par l'utilisateur.
# ---------------------------------------------------------------------------

# Import arcpy module
import arcpy , os
from arcpy import env

# Check out any necessary licenses
arcpy.CheckOutExtension("spatial")

# Script arguments

# Modèle numérique terrain
MNT = arcpy.GetParameterAsText(0)

# Réseau de haie
ReseauHaie = arcpy.GetParameterAsText(1)

# Angle de tolérance
Angle = arcpy.GetParameterAsText(2)

# Sortie
HAIAntiErosif = arcpy.GetParameterAsText(3)

# environnement de travail
workspace = os.path.dirname(HAIAntiErosif)

# on récuèpe de nom du fichier de sortie
path, nameout = os.path.split(HAIAntiErosif)

# l'encodage utf8 nécessaire dans un arctoolbox
nameout = nameout.encode('utf8')
Angle = Angle.encode('utf8')

# parametrage de l'environnement de travail
env.workspace = workspace
env.overwriteOutput = True
msg = arcpy.AddMessage
#  * ******************************Travail sur la pente

# Process: Pente
msg("Calculating slope ...")
arcpy.gp.Slope_sa(MNT, "OutPente", "DEGREE", "1")

# Process: ReclassPente
msg("Reclassing slope 0-7 : 0; 0-400: 1 ...")
arcpy.gp.Reclassify_sa("OutPente", "Value", "0 7 0;7 400 1", "PenteClass", "DATA")

# Process: VectoPente
msg("Vectorisating of slope reclass ...")
arcpy.RasterToPolygon_conversion("PenteClass", "PenteVect", "NO_SIMPLIFY", "VALUE")

# Process: AddFieldPente
msg("Adding and filling slope field ...")
arcpy.AddField_management("PenteVect", "Pente", "DOUBLE", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")


# Process: CalculPenteField
arcpy.CalculateField_management("PenteVect", "Pente", "[grid_code]", "VB", "")

# Process: DelPVField
arcpy.DeleteField_management("PenteVect", "Id;grid_code")

# ************************************ Travail sur l'exposition.

# Process: Exposition
msg("Calculating exposition ...")
arcpy.gp.Aspect_sa(MNT, "OutExpo")

# Process: ReclassExpo
msg("Reclassing exposition ...")
arcpy.gp.Reclassify_sa("OutExpo", "Value", "-2 0 -1;0 22.5 0;22.5 67.5 45;67.5 112.5 90;112.5 157.5 135;157.5 202.5 180;202.5 247.5 225;247.5 292.5 270;292.5 337.5 315;337.5 360 360", "ExpoClass", "DATA")

# Process: VectoExpo
msg("Vectorising exposition")
arcpy.RasterToPolygon_conversion("ExpoClass", "ExpoVect", "NO_SIMPLIFY", "VALUE")

# Process: AddFieldExpo
msg("Adding and filling expostion field")
arcpy.AddField_management("ExpoVect", "exposition", "DOUBLE", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")

# Process: CalculExpoField
arcpy.CalculateField_management("ExpoVect", "exposition", "[grid_code]", "VB", "")

# Process: DelEVField
arcpy.DeleteField_management("ExpoVect", "Id;grid_code")

# ********************************** Intersection Calcul azimut et comparaison avec pente et exposition

# Process: Intersecter
msg("Intersecting slope, exposition, hedge...")
arcpy.Intersect_analysis(["PenteVect","ExpoVect", ReseauHaie], HAIAntiErosif, "NO_FID", "", "INPUT")


# Process: AddFieldAzimut
arcpy.AddField_management(HAIAntiErosif, "Azimut_haie", "FLOAT", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")

# Process: CalculFieldAzimut
arcpy.CalculateField_management(HAIAntiErosif, "Azimut_haie", "Azimut(math.atan2(!shape.lastPoint.X!-!shape.firstPoint.X!,!shape.lastPoint.Y!-!shape.firstPoint.Y!)*(180/math.pi))", "PYTHON_9.3", "def Azimut(azi):\\n    if azi<0:azi+=360\\n    return azi")

# Process: AddFieldAntiErosif
arcpy.AddField_management(HAIAntiErosif, "AntiErosif", "TEXT", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")

# Process: CalCulAntiErosif
expression = """def Evaluate (pdPente, pdExpo, pdAzi):
    # ************** fonction *********************
    # cette fonction evaluera si une haie se positionne avec un angle +/- 30° à la perpendiculaire de la pente.
    # on déclare les fonctions qui seront utilisées.
    # 1 ) il faut évaluer si la haie est sur une pente de plus de 7 ° si non on n'est pas sur une pente
    #    de plus de 7°
    # 2) on évalue la l'angle de la haie sur 180°
    #    on ramène l'angle à 180°

    AntiErosif = \"non\"
    if pdAzi>180 : pdAzi-=180
    if pdPente==0 : AntiErosif = \"non\"
    if pdExpo==-1 : AntiErosif = \"non\"
    if pdPente==1 :
        # b1, b2 , b3, b4 récupère respectivement les enregistrement de la liste.
        Intervales = perpendiculaire(pdExpo)
        b1, b2, b3, b4 = Intervales
        # on teste si l'azimut de la haie se trouve dans l'intervales de la perpendiculaire à +/-30
        if b1<pdAzi<b2 or b3<pdAzi<b4 : AntiErosif = \"oui\"
    return AntiErosif

def perpendiculaire(angle):
    Intervales=[]

    # on cherche la perpendiculaire à la pente :
    perpent=angle+90

    # on vérifie que la perpendiculaire n'est pas supérieur à 360
    # qi oui on ajoute 360°
    if perpent>180 : perpent=perpent-180

    # Les bornes sont définis avec +/- 30°
    B1, B2 = perpent- """+ str(Angle) + """, perpent+"""+ str(Angle) +"""# Cas normale
    Intervales=[B1,B2,0,0]

    #Cas 1 : si la borne inférieure est négative.
    if B1<0:Intervales=[0,B2,B1+180,180]

    #Cas2
    if B2>180: Intervales=[0,B2-180,B1,180]
    return Intervales"""
msg("Calculating erosive role ...")
arcpy.CalculateField_management(HAIAntiErosif, "AntiErosif", "Evaluate( !Pente!, !exposition!, !Azimut_haie!)", "PYTHON_9.3", expression)


