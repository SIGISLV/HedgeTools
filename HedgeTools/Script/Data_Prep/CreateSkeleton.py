# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# CreateSkeleton.py
# Created on: 2013-11-20 13:43:37.00000
#   (generated by ArcGIS/ModelBuilder)
# Usage: CreateSkeleton <Input_Polygons> <Densify_Distance> <Expression> <Output_Skeleton>
# Description:
# ---------------------------------------------------------------------------

# Set the necessary product code
# import arcinfo


# Import arcpy module
import arcpy, os
from arcpy import env
env.overwriteOutput=True

def CompareMinTresHold(InFeatureClass, InTreshold):
    """
    Analyse la longueur des lignes en entrée. Compare avec le seuil spécifié. Renvoie vrai si
    des éléments de la liste sont inférieur à la longueur spécifiée.
    inputs :
           InFeaturesClass : la couche d'entité à analyser
           InTreshold : seuil en entrée la longueur maximale de de la ligne.
    Output :
    """
    # Parcours de la Classe d'entité
    scur = arcpy.SearchCursor(InFeatureClass)
    lVal = list()
    for row in scur:
        g= arcpy.Geometry()
        g=row.getValue('Shape')
        lVal.append(g.length)
    # retourner le résultat de la comparaison minimun de la liste et seuil:
    return min(lVal)>InTreshold


def createSkeleton(Input_Polygons, Densify_Distance, geodata):
    """
    Créer le skelete de l'entité en entrée. Les entités de transition sont crées
    dans le répertoire spécifié.

    inputs :
           Inputs_Polygones : chemin de la classe d'entité. Cette entité a due subir une simplification
           de géométrie.
           geodata : chemin de l'environnement de travail.
    output :
           Retourne le chemin du skelete.
    """
    # Paramètre d'environnement :
    arcpy.env.workspace=geodata

    # copier la couche avant l'édition
    arcpy.AddMessage("Copie de la couche d'entrée ...")
    arcpy.CopyFeatures_management(Input_Polygons,"InPoly_copy")

    # Process: Densify
    arcpy.AddMessage("Densification du polygone ...")
    arcpy.Densify_edit("InPoly_copy", "DISTANCE", Densify_Distance, "0.1 Meters", "10")

    # Process: Feature Vertices To Points
    arcpy.AddMessage("Conversion du polygone en point...")
    arcpy.FeatureVerticesToPoints_management("InPoly_copy", "points", "ALL")

    # Process: Create Thiessen Polygons
    arcpy.AddMessage("Création de polygones de voronoi ...")
    arcpy.CreateThiessenPolygons_analysis("points", "thiessen", "ONLY_FID")

    # Process: Clip
    arcpy.AddMessage("Découpe des polygones de voronoi par l'emprise intiale ...")
    arcpy.Clip_analysis("thiessen", Input_Polygons, "thiessen_clip", "")

    # Process: Feature To Line
    arcpy.AddMessage("Conversion des polygones de voronoi découpés en ligne ...")
    arcpy.FeatureToLine_management("thiessen_clip", "allfc", "", "ATTRIBUTES")

    # Process: Feature To Line (2)
    arcpy.AddMessage("Conversion de l'emprise initiale en ligne ...")
    arcpy.FeatureToLine_management("InPoly_copy", "exterior", "", "ATTRIBUTES")

    # Process: Symmetrical Difference
    arcpy.AddMessage("Symétrie différentielle entre ligne de voronoi et ligne emprise initiale ...")
    arcpy.SymDiff_analysis("allfc", "exterior", "interior", "ALL", "")

    # Transformer en couche le layer interior.
    arcpy.MakeFeatureLayer_management("interior","layinterior")

    # Appliquer une requête spatiale:
    arcpy.AddMessage("Selection spatiale de l'axe médian avec arc pendant ...")
    arcpy.SelectLayerByLocation_management("layinterior","INTERSECT", "exterior",  2, "SWITCH_SELECTION")
    arcpy.SelectLayerByLocation_management("layinterior","INTERSECT", "exterior",  0.5, "REMOVE_FROM_SELECTION")

    # Copier la couche de sélection :
    arcpy.CopyFeatures_management("layinterior", "MedianAxe_ArcPendant")

    # Fusioner les lignes entre elles :
    arcpy.AddMessage("Fusion des lignes qui se touchent ...")
    arcpy.UnsplitLine_management("MedianAxe_ArcPendant", "MedAxePend_Unsplit")

    # on supprime les doublons. il faut vérifier que les :
    num=None
    arcpy.AddMessage("Suppression des doublons ...")
    while num !=0:
        arcpy.DeleteIdentical_management("MedAxePend_Unsplit", "Shape")
        mess = arcpy.GetMessages(0)
        messSplit = mess.split('\n')
        stnum = str(messSplit[2][0:messSplit[2].find('doublons')-1])
        num = int(stnum)
        arcpy.AddMessage( stnum + " doublons supprimés ...")

    # Supprimer les arcs pendants inférieure à 30 m :
    ValUnderTres, i = True, 1
    InFeature = "MedAxePend_Unsplit"
    outFeature = "MedAxePend_Unsplit" + str(i)

    # boucle permettant de supprimer les arcs pendants avec vérification.
    arcpy.AddMessage("Suppression des arcs pendants ...")
    while ValUnderTres :
          arcpy.TrimLine_edit(InFeature,30,"DELETE_SHORT")
          arcpy.UnsplitLine_management(InFeature, outFeature)
          # on cherche si les lignes sont inférieures au seuil :
          ValUnderTres = CompareMinTresHold(outFeature,30)
          if ValUnderTres: arcpy.AddMessage("Des arcs pendants subsistent encore ...")
          if not ValUnderTres: arcpy.AddMessage("Aucun arcs pendants détecté ...")
          # on prepare les variables d'entrée et de sortie :
          InFeature=outFeature
          i=+1
          outFeature= "MedAxePend_Unsplit " + str(i)

    # prepare output data :
    arcpy.AddMessage("Préparation la classe d'entité en sortie ...")
    arcpy.CopyFeatures_management("MedAxePend_Unsplit", Output_Skeleton)

    # On retourne la classe d'entité
    arcpy.AddMessage("Fin du processus ...")
    return os.path.join(Output_Skeleton)

if __name__=="__main__":
   # Script arguments

   Input_Polygons = arcpy.GetParameterAsText(0)

   Densify_Distance = arcpy.GetParameter(1)

   Output_Skeleton = arcpy.GetParameterAsText(2)

   """
   Input_Polygons =  r'E:\7_CDD\HedgeTools\DataTest\Data.gdb\Boi_test_clean'

   Densify_Distance = 1

   Output_Skeleton = r'E:\7_CDD\HedgeTools\DataTest\Data.gdb\Bois_Test_Skelet'
   """

   gdbout=os.path.dirname(Output_Skeleton)
   dirpath = os.path.dirname(gdbout)
   geodata=os.path.join(dirpath,"tmp.gdb")
   if not arcpy.Exists(geodata):arcpy.CreateFileGDB_management(dirpath,"tmp.gdb")

   # Lancer la fonction :
   createSkeleton(Input_Polygons,Densify_Distance,geodata)